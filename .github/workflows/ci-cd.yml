name: CI/CD for Etoubib Api

on:
  push:
    branches:
      - main
      - staging
  pull_request:
    branches:
      - main
      - staging

env:
  DOCKER_IMAGE: etoubib-api

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Run unit tests (log for now)
        run: |
          echo "Running unit tests..."
          # we will add our test here in future
          # npm run test

  set-environment: 
      runs-on: ubuntu-latest 
      needs: test
      outputs: 
        current_env: ${{ steps.set_env.outputs.current_env }}
      steps:
        - name: Check if prod
          if: endsWith(github.ref, '/main') #if the triggering branch is 'main'
          run: |
            echo "ENVIRONMENT_NAME=production" >> $GITHUB_ENV
        - name: Check if staging
          if: endsWith(github.ref, '/staging') #if the triggering branch is 'dev'
          run: |
            echo "ENVIRONMENT_NAME=staging" >> $GITHUB_ENV
        - name: Set output
          id: set_env
          run: |
            echo "current_env=${{ env.ENVIRONMENT_NAME }}" >> $GITHUB_OUTPUT
  
  build_for_migration:
    runs-on: self-hosted
    needs: set-environment
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Build Docker image for migration
        run: |
          docker build -t etoubib-migration-build -f migration.dockerfile .

  migration:
    runs-on: self-hosted
    needs: [build_for_migration, set-environment]
    environment:
      name: ${{ needs.set-environment.outputs.current_env }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Run migration inside Docker container
        run: |
          docker run -e TYPEORM_URL=${{ secrets.TYPEORM_URL }} etoubib-migration-build

  build_app:
    runs-on: self-hosted  # Specify the self-hosted runner here
    needs: [migration, set-environment]
    environment: 
      name: ${{ needs.set-environment.outputs.current_env }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Build Docker image for app
        run: |
          docker build -t ${{ env.DOCKER_IMAGE }} .
      
      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Login to Amazon ECR
        run: |
            aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_REPOSITORY }}
  
      - name: Tag Docker image
        run: |
          docker tag ${{ env.DOCKER_IMAGE }}:latest ${{ secrets.ECR_REPOSITORY }}:$GITHUB_SHA
    
      - name: Push Docker image to ECR
        run: |
          docker push ${{ secrets.ECR_REPOSITORY }}:$GITHUB_SHA

  deploy:
    runs-on: self-hosted
    needs: [build_app, set-environment]
    environment: 
      name: ${{ needs.set-environment.outputs.current_env }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Pull Docker image and deploy API
        run: |
          echo "Pulling latest Docker image from ECR..."
          docker pull ${{ secrets.ECR_REPOSITORY }}:$GITHUB_SHA

          echo "Stopping any existing containers..."
          docker ps -q --filter "name=${{ env.DOCKER_IMAGE }}" | xargs -r docker stop --time=30

          echo "Running the new Docker container..."
          docker run -e TYPEORM_URL=${{ secrets.TYPEORM_URL }} -d -p 3000:3000 --name ${{ env.DOCKER_IMAGE }} ${{ secrets.ECR_REPOSITORY }}:$GITHUB_SHA